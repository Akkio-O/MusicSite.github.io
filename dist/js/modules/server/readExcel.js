const fs=require("fs"),ejs=require("ejs"),xlsx=require("xlsx"),path=require("path");async function readExcel(e){const t=xlsx.readFile(e);return xlsx.utils.sheet_to_json(t.Sheets[t.SheetNames[0]],{header:1})}async function insertOrUpdateProducts(e,t,s,r){const o=s.promise();await Promise.all(e.map((async e=>{try{const{CV_PRICE_13:s,CV_PRICE_18:a,IP_PROP140:i,IC_GROUP0:c,IC_GROUP1:n,IC_GROUP2:d}=e;if(s&&a&&"Продукт снят с производства"!==i){e.created_at=new Date;const s="INSERT INTO Product SET ? ON DUPLICATE KEY UPDATE ?";await o.query(s,[e,e]),console.log("Данные успешно добавлены в таблицу Product или обновлены"),d?await addToCategoryFolder(d,e,t,r):n&&await addToCategoryFolder(n,e,t,r)}else console.log("Продукт снят с производства, данные не добавлены в таблицу Product и не обновлены")}catch(e){console.error("Ошибка при добавлении или обновлении данных в таблицу Product:",e)}})))}async function deleteUnusedFiles(e,t){const s=await getProductIdsFromTable(t);await deleteFilesRecursive(e,s)}async function deleteFilesRecursive(e,t){const s=await fs.promises.readdir(e);await Promise.all(s.map((async s=>{const r=path.join(e,s);(await fs.promises.stat(r)).isDirectory()?await deleteFilesRecursive(r,t):t.includes(s)||(await fs.promises.unlink(r),console.log(`Файл ${s} удален.`))})))}async function getProductIdsFromTable(e){const t=e.promise(),[s]=await t.query("SELECT IE_XML_ID FROM Product");return s.map((e=>e.IE_XML_ID+".html"))}async function renderHTMLFiles(e,t,s){const r=await getProductsForHTMLRendering(s),o=[];await Promise.all(r.map((async s=>{const r=[s.IC_GROUP0,s.IC_GROUP1,s.IC_GROUP2].filter(Boolean).map((e=>decodeURIComponent(e))).join("/"),a=path.join(e,r),i=`${s.IE_XML_ID}.html`,c=path.join(a,i),n=ejs.render(t,{product:s});n!==await readFileAsync(c)?(await fs.promises.writeFile(c,n,"utf8"),console.log(`HTML файл ${i} обновлен.`)):o.push(i)}))),console.log(`${o.length} HTML файлов существует и не требует обновления.`)}async function createOrCheckFolderStructure(e,t){await Promise.all(e.map((async e=>{const{IC_GROUP0:s,IC_GROUP1:r,IC_GROUP2:o}=e,a=path.join(t,s);try{await fs.promises.access(a)}catch(e){"ENOENT"===e.code&&await fs.promises.mkdir(a,{recursive:!0})}if(r){const e=path.join(a,r);try{await fs.promises.access(e)}catch(t){"ENOENT"===t.code&&await fs.promises.mkdir(e,{recursive:!0})}if(o){const t=path.join(e,o);try{await fs.promises.access(t)}catch(e){"ENOENT"===e.code&&await fs.promises.mkdir(t,{recursive:!0})}}}})))}async function addToCategoryFolder(e,t,s,r){const o=[t.IC_GROUP0,t.IC_GROUP1,t.IC_GROUP2?t.IC_GROUP2:void 0].filter(Boolean).join("/");if(console.log("Encoded folders:",o),o){const e=path.join(r,o);console.log("Full path:",e);try{await fs.promises.mkdir(e,{recursive:!0})}catch(e){if("EEXIST"!==e.code)throw e}const a=`${t.IE_XML_ID}.html`,i=path.join(e,a),c=ejs.render(s,{product:t});try{c!==await fs.promises.readFile(i,"utf8")&&(await fs.promises.writeFile(i,c,"utf8"),console.log(`HTML файл ${a} обновлен.`))}catch(e){"ENOENT"===e.code&&(await fs.promises.writeFile(i,c,"utf8"),console.log(`HTML файл ${a} создан.`))}}else console.log(`Не удалось определить путь для категории "${e}"`)}async function readFileAsync(e){return fs.promises.readFile(e,"utf8").catch((()=>""))}async function getProductsForHTMLRendering(e){const t=e.promise(),[s]=await t.query("SELECT * FROM Product");return s}module.exports={readExcel,insertOrUpdateProducts,deleteUnusedFiles,deleteFilesRecursive,getProductIdsFromTable,renderHTMLFiles,createOrCheckFolderStructure,addToCategoryFolder,readFileAsync,getProductsForHTMLRendering};